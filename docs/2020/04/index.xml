<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>4 月 on 叶王日记</title>
    <link>https://ikingye.github.io/diary/docs/2020/04/</link>
    <description>Recent content in 4 月 on 叶王日记</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://ikingye.github.io/diary/docs/2020/04/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>2020-04-09</title>
      <link>https://ikingye.github.io/diary/docs/2020/04/09/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/diary/docs/2020/04/09/</guid>
      <description>2020 年 4 月 9 日（星期四） 今日待办     生活  编程 基本算法 排序算法  插入排序类  直接插入排序 希尔排序 二分法插入排序   选择排序类  直接选择排序 堆排序   交换排序类  冒泡排序 快速排序   归并排序 基数排序  时间 / 空间复杂度 排序大的分类可分为内排序和外排序，不需要访问外存就能进行排序的叫做内排序。
   排序方法 时间复杂度（平均） 时间复杂度（最坏) 时间复杂度（最好) 空间复杂度 稳定性 复杂性     希尔排序 O(nlog2n) O(n2) O(n) O(1) 不稳定 较复杂   堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 较复杂   快速排序 O(nlog2n) O(n2) O(nlog2n) O(nlog2n) 不稳定 较复杂   归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(n) 稳定 较复杂   直接插入排序 O(n2) O(n2) O(n) O(1) 稳定 简单   直接选择排序 O(n2) O(n2) O(n2) O(1) 不稳定 简单   冒泡排序 O(n2) O(n2) O(n) O(1) 稳定 简单   基数排序 O(d(n+r)) O(d(n+r)) O(d(n+r)) O(n+r) 稳定 较复杂    稳定排序与不稳定排序 稳定排序：假设在待排序的文件中，存在两个或两个以上的记录具有相同的关键字，在用某种排序法排序后，若这些相同关键字的元素的相对次序仍然不变，则这种排序方法是稳定的。</description>
    </item>
    
    <item>
      <title>2020-04-08</title>
      <link>https://ikingye.github.io/diary/docs/2020/04/08/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/diary/docs/2020/04/08/</guid>
      <description>2020 年 4 月 8 日（星期三） 今日待办     编程 依赖注入 可以通过多种方式为实例提供必要的依赖关系：
 构造函数注入 属性注入 方法注入  构造函数注入 构造函数注入是许多依赖注入框架的首选方法，常受依赖注入框架的青睐。
它清楚地告诉我们创建特定组件所需的所有依赖关系，并且这些依赖不是可选的，这些依赖关系在整个组件中应该都是必需的。
public class DataProcessor { private final DbManager manager; private final Calculator calculator; public DataProcessor(DbManager manager, Calculator calculator) { this.manager = manager; this.calculator = calculator; } // ... }  优点：  不变性：依赖关系始终如初。   缺点  必须在初始化时提供所有依赖项。  有时，我们无法自己初始化一个组件，或者在某个时刻我们无法提供组件的所有依赖关系。或者我们需要使用另外一个构造函数。一旦设置了依赖项，我们就无法再改变它们了。      属性注入 属性注入更适合可选参数，例如监听或委托。又或是我们无法在初始化时提供依赖关系。
其它编程语言，例如 Swift，大量使用了带属性的 委托模式。因此，使用属性注入将使其它语言的开发人员更熟悉我们的代码。</description>
    </item>
    
    <item>
      <title>2020-04-07</title>
      <link>https://ikingye.github.io/diary/docs/2020/04/07/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/diary/docs/2020/04/07/</guid>
      <description>2020 年 4 月 7 日（星期二） 今日待办  201 PoSD 翻译  修改负责的 5 个 Principles 并提交到 icode 前 20 个 Principles 合并到 word，并提交给出版社进行初审     编程 编程哲学 中文房间 中文房间（英语：Chinese room），是由约翰・希尔勒提出的一个思想实验，借以反驳强人工智能的观点。根据强人工智能的观点，只要计算机拥有了适当的程序，理论上就可以说计算机拥有它的认知状态并且可以像人一样地进行理解活动。
该实验出自约翰・罗杰斯・希尔勒的论文《心灵、大脑和程序》（ Minds, Brains, and Programs）中，发表于 1980 年的《 行为与脑科学（英语：Behavioral and Brain Sciences）》。
中文房间思想实验是什么？它是否成功地否决了图灵测试的有效性？
中文房间是否可以否定人类会思考？
因果论与自由意志 k8s 相关 canonical/multipass  Multipass orchestrates virtual Ubuntu instances https://multipass.run
# 创建一个 VM, 1GB 内存和 5GB 磁盘 multipass launch --name k3s --mem 1G --disk 5G # 为 VM 启动一个 shell multipass shell k3s # 在其上安装 k3s curl -sfL https://get.</description>
    </item>
    
    <item>
      <title>2020-04-06</title>
      <link>https://ikingye.github.io/diary/docs/2020/04/06/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/diary/docs/2020/04/06/</guid>
      <description>2020 年 4 月 6 日（星期一） 备注：
 清明节放假  今日待办  201 PoSD 翻译  前 20 个 Principles 翻译审校（评论） 编委会讨论前 20 个 Principles 翻译修改版 修改负责的 5 个 Principles 并提交到 icode     今日总结 </description>
    </item>
    
    <item>
      <title>2020-04-03</title>
      <link>https://ikingye.github.io/diary/docs/2020/04/03/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/diary/docs/2020/04/03/</guid>
      <description>2020 年 4 月 3 日（星期五） 今日待办     编程 Bookinfo Application 安装 istio istioctl manifest apply --set profile=demo kubectl label namespace default istio-injection=enabled 参考：https://istio.io/docs/setup/getting-started/
运行 Bookinfo sample application alias k=&amp;#34;kubectl&amp;#34; k apply -f samples/bookinfo/platform/kube/bookinfo.yaml k get services 查看 Bookinfo 应用是否正常
by checking for the page title in the response
kubectl exec -it $(kubectl get pod -l app=ratings -o jsonpath=&amp;#39;{.items[0].metadata.name}&amp;#39;) -c ratings -- curl productpage:9080/productpage | grep -o &amp;#34;&amp;lt;title&amp;gt;.</description>
    </item>
    
    <item>
      <title>2020-04-02</title>
      <link>https://ikingye.github.io/diary/docs/2020/04/02/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/diary/docs/2020/04/02/</guid>
      <description>2020 年 4 月 2 日（星期四） 今日待办     编程 Istio 安装 minikube minikube start --image-mirror-country=&#39;cn&#39; --registry-mirror=https://registry.docker-cn.com
安装 istio istioctl manifest apply --set profile=demo kubectl label namespace default istio-injection=enabled 参考：https://istio.io/docs/setup/getting-started/
运行 Bookinfo sample application kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml kubectl get services 一切顺利，输出 service list。
过了一会，报错，连不上 server
The connection to the server 192.168.99.100:8443 was refused - did you specify the right host or port? minikube status minikube start --image-mirror-country=&amp;#39;cn&amp;#39; --registry-mirror=https://registry.</description>
    </item>
    
  </channel>
</rss>